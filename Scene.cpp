//============================================================================================================
//
//  [SCene.cpp] Author : Masaki Kuboki
//
//============================================================================================================
#include "Scene.h"

CScene *CScene::m_Scene[3][SCENE_COUNT] = { NULL };


//============================================================================================================
//
//
//
//============================================================================================================
CScene::CScene(int Priority)
{
	m_Priority = Priority;

	for (int i = 0; i < SCENE_COUNT; i++)
	{
		if (m_Scene[Priority][i] == NULL)
		{
			m_Scene[Priority][i] = this;
			break;
		}
	}
}

//============================================================================================================
//
//  UninitAll
//
//============================================================================================================
void CScene::UninitAll()
{
	for (int n = 0; n < PRIORITY_NUM; n++)
	{
		for (int i = 0; i < SCENE_COUNT; i++)
		{
		
			if (m_Scene[n][i] != NULL)
			{
				m_Scene[n][i]->Uninit();
			}
		}
	}
}

//============================================================================================================
//
//  UpdateAll
//
//============================================================================================================
void CScene::UpdateAll()
{
	for (int n = 0; n < PRIORITY_NUM; n++)
	{
		for (int i = 0; i < SCENE_COUNT; i++)
		{
		
			if (m_Scene[n][i] != NULL)
			{
				m_Scene[n][i]->Update();
			}
		}
	}
}

//============================================================================================================
//
//  DrawAll
//
//============================================================================================================
void CScene::DrawAll()
{
	for (int n = 0; n < PRIORITY_NUM; n++)
	{
		for (int i = 0; i < SCENE_COUNT; i++)
		{
			if (m_Scene[n][i] != NULL)
			{
				m_Scene[n][i]->Draw();
			}
		}
	}
}

//============================================================================================================
//
//  ReleseAll
//
//============================================================================================================
void CScene::ReleaseAll()
{

	for (int n = 0; n < PRIORITY_NUM; n++)
	{
		for (int i = 0; i < SCENE_COUNT; i++)
		{
			if (m_Scene[n][i] != NULL)
			{
				m_Scene[n][i]->Uninit();
				m_Scene[n][i] = nullptr;
				delete m_Scene[n][i];
			}
		}
	}
}

//============================================================================================================
//
//  Relese
//
//============================================================================================================
void CScene::Release()
{
	for (int i = 0; i < SCENE_COUNT; i++)
	{
		if (m_Scene[m_Priority][i] == this)
		{
			m_Scene[m_Priority][i] = NULL;
			Uninit();
			delete this;
			break;
		}
	}
}

//============================================================================================================
//
// SetPosition
//
//============================================================================================================
void CScene::SetPosition(D3DXVECTOR3 Position)
{
	D3DXVECTOR3 SetPosition = Position;
}